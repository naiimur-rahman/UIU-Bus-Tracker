<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>UIU Bus Tracker</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" id="app-manifest">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Plus Jakarta Sans"', 'sans-serif'],
                    },
                    colors: {
                        brand: {
                            50: '#fff7ed',
                            100: '#ffedd5',
                            500: '#f97316', 
                            600: '#ea580c',
                            900: '#7c2d12',
                        }
                    },
                    animation: {
                        'float': 'float 6s ease-in-out infinite',
                        'pulse-glow': 'pulse-glow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'countdown-pulse': 'countdown-pulse 1s ease-in-out infinite',
                        'shake': 'shake 0.5s ease-in-out',
                        'audio-wave': 'audio-wave 1.5s ease-in-out infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        'pulse-glow': {
                            '0%, 100%': { opacity: '1', boxShadow: '0 0 0 0px rgba(34, 197, 94, 0.7)' },
                            '50%': { opacity: '.5', boxShadow: '0 0 0 15px rgba(34, 197, 94, 0)' },
                        },
                        'countdown-pulse': {
                            '0%, 100%': { opacity: '1', transform: 'scale(1)' },
                            '50%': { opacity: '0.7', transform: 'scale(1.05)' },
                        },
                        'shake': {
                            '0%, 100%': { transform: 'translateX(0)' },
                            '10%, 30%, 50%, 70%, 90%': { transform: 'translateX(-2px)' },
                            '20%, 40%, 60%, 80%': { transform: 'translateX(2px)' },
                        },
                        'audio-wave': {
                            '0%, 100%': { height: '10px' },
                            '50%': { height: '20px' },
                        }
                    }
                }
            }
        }
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        .glass {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.07);
        }
        .dark .glass {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2);
        }
        .dark-map-tiles {
            filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
        }
        .view-section {
            position: absolute;
            inset: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
            visibility: hidden;
            overflow-y: hidden;
            z-index: 0;
            display: flex;
            flex-direction: column;
        }
        .view-active {
            opacity: 1 !important;
            pointer-events: auto !important;
            transform: scale(1) !important;
            z-index: 100 !important;
            visibility: visible !important;
        }
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #f97316;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes drive {
            0% { transform: translateY(0) rotate(3deg); }
            50% { transform: translateY(-6px) rotate(0deg); }
            100% { transform: translateY(0) rotate(3deg); }
        }
        .animate-drive { animation: drive 1.5s ease-in-out infinite; }
        .pulse-ring::before {
            content: ''; position: absolute; left: 0; top: 0; bottom: 0; right: 0;
            border-radius: 50%; border: 2px solid white; animation: ring 1.5s infinite;
        }
        @keyframes ring { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(2); opacity: 0; } }
        .leaflet-div-icon { background: transparent; border: none; }
        body { overscroll-behavior: none; }
        #view-profile { background-color: rgb(248 250 252) !important; }
        .dark #view-profile { background-color: rgb(15 23 42) !important; }
        

        /* Custom Leaflet Controls */
        .leaflet-bar { border: none !important; box-shadow: none !important; }
        .leaflet-bar a {
            border-radius: 50% !important;
            width: 40px !important;
            height: 40px !important;
            line-height: 40px !important;
            background-color: white !important;
            color: #64748b !important;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
            margin-bottom: 8px !important;
            border-bottom: none !important;
            transition: all 0.2s ease;
        }
        .dark .leaflet-bar a {
            background-color: #1e293b !important;
            color: #cbd5e1 !important;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3) !important;
        }
        .leaflet-bar a:hover {
            background-color: #f8fafc !important;
            transform: scale(1.05);
            color: #f97316 !important;
        }
        .dark .leaflet-bar a:hover {
            background-color: #334155 !important;
        }
        
        /* Countdown timer */
        .countdown-timer {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        /* Background audio indicator */
        .audio-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            animation: slideIn 0.3s ease-out;
        }
        
        .audio-visualizer {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 20px;
        }
        
        .audio-bar {
            width: 3px;
            background: #10b981;
            border-radius: 2px;
        }
        
        .audio-bar:nth-child(1) { animation: audio-wave 1.5s ease-in-out infinite; }
        .audio-bar:nth-child(2) { animation: audio-wave 1.5s ease-in-out infinite 0.1s; }
        .audio-bar:nth-child(3) { animation: audio-wave 1.5s ease-in-out infinite 0.2s; }
        .audio-bar:nth-child(4) { animation: audio-wave 1.5s ease-in-out infinite 0.3s; }
        .audio-bar:nth-child(5) { animation: audio-wave 1.5s ease-in-out infinite 0.4s; }
        
        @keyframes slideIn {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Fullscreen warning */
        .fullscreen-warning {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #f97316, #ea580c);
            color: white;
            text-align: center;
            padding: 12px;
            font-size: 14px;
            font-weight: bold;
            z-index: 9999;
            animation: shake 0.5s ease-in-out;
        }
        
        /* Install prompt */
        .install-prompt {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px;
            border-radius: 16px;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Keep awake indicator */
        .keep-awake {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 999;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        /* Battery warning */
        .battery-warning {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(220, 38, 38, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 999;
            display: flex;
            align-items: center;
            gap: 8px;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-slate-950 text-slate-800 dark:text-gray-100 font-sans h-[100dvh] w-screen overflow-hidden transition-colors duration-300 relative selection:bg-brand-500 selection:text-white dot-pattern">

    <!-- Silent Audio Player (Hidden) -->
    <audio id="silent-audio" loop crossorigin="anonymous">
        <!-- We'll generate silent audio programmatically -->
    </audio>

    <!-- Background Audio Indicator -->
    <div id="audio-indicator" class="audio-indicator hidden">
        <div class="audio-visualizer">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
        </div>
        <span>Background audio active</span>
        <button onclick="app.toggleAudioIndicator()" class="ml-2 text-gray-300 hover:text-white">
            <i class="fas fa-times"></i>
        </button>
    </div>

    <!-- Keep Awake Indicator -->
    <div id="keep-awake-indicator" class="keep-awake hidden">
        <i class="fas fa-eye mr-2"></i>Keeping Awake
    </div>

    <!-- Battery Warning -->
    <div id="battery-warning" class="battery-warning hidden">
        <i class="fas fa-battery-quarter mr-2"></i>
        <span>Low battery may affect tracking</span>
    </div>

    <!-- Fullscreen Warning -->
    <div id="fullscreen-warning" class="fullscreen-warning hidden">
        <i class="fas fa-expand-alt mr-2"></i>Keep this tab OPEN for continuous tracking
    </div>

    <!-- Install Prompt -->
    <div id="install-prompt" class="install-prompt hidden">
        <div class="flex items-center justify-between">
            <div>
                <div class="font-bold">Install as App</div>
                <div class="text-sm opacity-90">For better background tracking</div>
            </div>
            <button onclick="app.installPWA()" class="bg-white text-purple-600 px-4 py-2 rounded-full font-bold hover:bg-gray-100">
                Install
            </button>
        </div>
        <button onclick="app.hideInstallPrompt()" class="absolute top-2 right-2 text-white">
            <i class="fas fa-times"></i>
        </button>
    </div>

    <div class="fixed inset-0 overflow-hidden pointer-events-none z-0">
        <div class="absolute -top-20 -left-20 w-64 h-64 bg-brand-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 animate-float"></div>
        <div class="absolute top-1/2 -right-20 w-72 h-72 bg-purple-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 animate-float" style="animation-delay: 2s"></div>
        <div class="absolute -bottom-20 left-1/3 w-80 h-80 bg-pink-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 animate-float" style="animation-delay: 4s"></div>
    </div>

    <div id="global-controls" class="z-[500] relative transition-opacity duration-300 pointer-events-none">
        <button onclick="app.toggleTheme()" class="fixed top-4 right-4 w-10 h-10 rounded-full glass flex items-center justify-center text-slate-600 dark:text-yellow-400 shadow-lg hover:scale-110 transition-transform cursor-pointer pointer-events-auto">
            <i class="fas fa-moon dark:hidden"></i>
            <i class="fas fa-sun hidden dark:block"></i>
        </button>
    </div>

    <!-- Rest of your HTML views remain the same -->
    <!-- ... [Your existing HTML for views] ... -->

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>

    <script type="module">
        /** APP CONFIG */
        const CONFIG = {
            mqtt: {
                protocol: 'wss',
                host: '09872002dac9410e9af391b1a7066483.s1.eu.hivemq.cloud',
                port: 8884,
                path: '/mqtt',
                username: 'naimur',
                password: 'Sohan786@',
                clientId: (() => {
                    let id = localStorage.getItem('mqtt_client_id');
                    if (!id) {
                        id = 'uiu-' + Math.random().toString(16).substr(2, 8);
                        localStorage.setItem('mqtt_client_id', id);
                    }
                    return id;
                })()
            },
            topics: {
                location: 'uiu/bus/location',
                presence: 'uiu/presence'
            },
            uiuCoords: [23.79790, 90.44970], 
            presenceInterval: 15000,
            minAccuracy: 50,
            autoStopMinutes: 30,
            locationInterval: 3000,
            wakeLockCheckInterval: 10000,
            silentAudio: {
                enabled: true, // Enable silent audio trick
                volume: 0.001, // Almost silent (0.1% volume)
                showIndicator: true // Show audio indicator
            }
        };

        /** GLOBAL STATE */
        const state = {
            client: null,
            isConnected: false,
            connectionDebounce: null, 
            role: null,
            driverId: null,
            driverRoute: null,
            driverDestination: null,
            driverUsername: null,
            isBroadcasting: false,
            watchId: null,
            wakeLock: null,
            activeBuses: {},
            activeUsers: new Map(),
            userCache: {},
            map: null,
            driverMap: null,
            driverMarker: null,
            markers: {},
            circles: {}, 
            lastSentTime: 0,
            sessionPoints: 0,
            sessionDistance: 0,
            lastLat: null,
            lastLng: null,
            tripStartTime: null,
            uptimeInterval: null,
            currentSmoothedSpeed: 0,
            countdownInterval: null,
            countdownTime: CONFIG.autoStopMinutes * 60,
            locationInterval: null,
            isTabVisible: true,
            deferredInstallPrompt: null,
            isInstalled: false,
            fullscreenWarningShown: false,
            wakeLockRetryCount: 0,
            silentAudio: null,
            audioContext: null,
            isAudioPlaying: false,
            batteryLevel: 1,
            batteryCheckInterval: null
        };

        /** APP CONTROLLER */
        const app = {
            init: () => {
                app.loadTheme();
                app.connectMqtt();
                app.setupManifest();
                app.checkPWAInstallation();
                app.setupVisibilityListeners();
                app.setupBeforeUnload();
                app.createSilentAudio();
                app.setupBatteryMonitoring();
                
                console.log("App Version: Silent Audio Background Tracking");
                
                // Check for existing session
                const savedDriverId = localStorage.getItem('active_driver_id');
                const savedRoute = localStorage.getItem('active_driver_route');
                
                if (savedDriverId && savedRoute) {
                    console.log("Restoring previous session...");
                    state.driverId = savedDriverId;
                    state.driverRoute = savedRoute;
                    state.driverDestination = localStorage.getItem('active_driver_dest');
                    state.driverDirection = localStorage.getItem('active_driver_dir');
                    state.driverUsername = localStorage.getItem('active_driver_username');
                    
                    app.setRole('driver-dashboard');
                    document.getElementById('driver-assigned-id').innerText = `${state.driverRoute} [${state.driverId}]`;

                    if (state.driverUsername) {
                        document.getElementById('driver-display-username-container').classList.remove('hidden');
                        document.getElementById('driver-display-username').innerText = state.driverUsername;
                    }

                    app.switchView('view-driver-dashboard');
                    app.initDriverMap();
                }

                setInterval(app.sendHeartbeat, CONFIG.presenceInterval);
                setInterval(app.cleanupStaleUsers, 10000);
                
                // Show install prompt if not installed
                setTimeout(() => {
                    if (!state.isInstalled && state.role === 'driver-dashboard') {
                        app.showInstallPrompt();
                    }
                }, 5000);
            },

            // === SILENT AUDIO IMPLEMENTATION ===
            createSilentAudio: () => {
                if (!CONFIG.silentAudio.enabled) return;
                
                try {
                    // Method 1: Create silent audio buffer programmatically
                    if (window.AudioContext || window.webkitAudioContext) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        state.audioContext = new AudioContext();
                        
                        // Create an empty stereo buffer at the sample rate of the AudioContext
                        const buffer = state.audioContext.createBuffer(2, state.audioContext.sampleRate * 600, state.audioContext.sampleRate);
                        
                        // Fill the buffer with silence
                        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                            const nowBuffering = buffer.getChannelData(channel);
                            for (let i = 0; i < buffer.length; i++) {
                                nowBuffering[i] = 0;
                            }
                        }
                        
                        // Create a source node from the buffer
                        const source = state.audioContext.createBufferSource();
                        source.buffer = buffer;
                        source.loop = true;
                        
                        // Create a gain node to control volume
                        const gainNode = state.audioContext.createGain();
                        gainNode.gain.value = CONFIG.silentAudio.volume;
                        
                        // Connect the graph
                        source.connect(gainNode);
                        gainNode.connect(state.audioContext.destination);
                        
                        state.silentAudio = {
                            source: source,
                            gainNode: gainNode,
                            context: state.audioContext
                        };
                        
                        console.log("Silent audio created using Web Audio API");
                    } 
                    // Method 2: Use HTML5 audio element with silent MP3
                    else {
                        const audio = document.getElementById('silent-audio');
                        
                        // Create a silent MP3 data URL (1 second of silence)
                        // Base64 encoded silent MP3
                        const silentMp3 = 'data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA//////////////////////////////////////////////////////////////////8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADgnABGiAAQBCqgCRMAAgEAH///////////////7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq//////////////////9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==';
                        
                        audio.src = silentMp3;
                        audio.loop = true;
                        audio.volume = CONFIG.silentAudio.volume;
                        
                        state.silentAudio = audio;
                        console.log("Silent audio created using HTML5 Audio");
                    }
                } catch (error) {
                    console.error("Error creating silent audio:", error);
                    CONFIG.silentAudio.enabled = false;
                }
            },

            startSilentAudio: () => {
                if (!CONFIG.silentAudio.enabled || !state.silentAudio) return;
                
                try {
                    if (state.audioContext && state.silentAudio.source) {
                        // Web Audio API method
                        if (state.audioContext.state === 'suspended') {
                            state.audioContext.resume();
                        }
                        state.silentAudio.source.start(0);
                        state.isAudioPlaying = true;
                    } else if (state.silentAudio instanceof HTMLAudioElement) {
                        // HTML5 Audio method
                        state.silentAudio.play().then(() => {
                            state.isAudioPlaying = true;
                        }).catch(error => {
                            console.error("Audio play failed:", error);
                            // Try to play with user interaction
                            document.addEventListener('click', app.resumeAudioOnInteraction, { once: true });
                        });
                    }
                    
                    // Show audio indicator
                    if (CONFIG.silentAudio.showIndicator) {
                        app.showAudioIndicator();
                    }
                    
                    console.log("Silent audio started");
                } catch (error) {
                    console.error("Error starting silent audio:", error);
                }
            },

            stopSilentAudio: () => {
                if (!CONFIG.silentAudio.enabled || !state.silentAudio) return;
                
                try {
                    if (state.audioContext && state.silentAudio.source) {
                        state.silentAudio.source.stop();
                        state.isAudioPlaying = false;
                    } else if (state.silentAudio instanceof HTMLAudioElement) {
                        state.silentAudio.pause();
                        state.silentAudio.currentTime = 0;
                        state.isAudioPlaying = false;
                    }
                    
                    // Hide audio indicator
                    app.hideAudioIndicator();
                    
                    console.log("Silent audio stopped");
                } catch (error) {
                    console.error("Error stopping silent audio:", error);
                }
            },

            resumeAudioOnInteraction: () => {
                if (state.isBroadcasting && state.silentAudio && state.silentAudio instanceof HTMLAudioElement) {
                    state.silentAudio.play().then(() => {
                        state.isAudioPlaying = true;
                        console.log("Audio resumed after user interaction");
                    });
                }
            },

            showAudioIndicator: () => {
                const indicator = document.getElementById('audio-indicator');
                if (indicator) {
                    indicator.classList.remove('hidden');
                    // Auto-hide after 10 seconds
                    setTimeout(() => {
                        if (state.isAudioPlaying) {
                            indicator.classList.add('hidden');
                        }
                    }, 10000);
                }
            },

            hideAudioIndicator: () => {
                const indicator = document.getElementById('audio-indicator');
                if (indicator) {
                    indicator.classList.add('hidden');
                }
            },

            toggleAudioIndicator: () => {
                const indicator = document.getElementById('audio-indicator');
                if (indicator) {
                    indicator.classList.add('hidden');
                }
            },

            // === BATTERY MONITORING ===
            setupBatteryMonitoring: () => {
                if ('getBattery' in navigator) {
                    navigator.getBattery().then(battery => {
                        state.batteryLevel = battery.level;
                        
                        battery.addEventListener('levelchange', () => {
                            state.batteryLevel = battery.level;
                            app.updateBatteryWarning();
                        });
                        
                        battery.addEventListener('chargingchange', () => {
                            app.updateBatteryWarning();
                        });
                        
                        app.updateBatteryWarning();
                    });
                } else if ('battery' in navigator) {
                    // Legacy battery API
                    navigator.battery.addEventListener('levelchange', () => {
                        state.batteryLevel = navigator.battery.level;
                        app.updateBatteryWarning();
                    });
                }
                
                // Check battery periodically
                state.batteryCheckInterval = setInterval(() => {
                    app.updateBatteryWarning();
                }, 60000); // Check every minute
            },

            updateBatteryWarning: () => {
                const warning = document.getElementById('battery-warning');
                if (!warning) return;
                
                if (state.batteryLevel < 0.2) {
                    warning.classList.remove('hidden');
                } else {
                    warning.classList.add('hidden');
                }
            },

            // === MODIFIED START BROADCAST WITH AUDIO ===
            startBroadcast: async () => {
                if (!navigator.geolocation) {
                    alert("Geolocation not supported");
                    return;
                }
                
                // Enhanced warning with audio explanation
                const warningMessage = `
ðŸš¨ IMPORTANT FOR BACKGROUND TRACKING:

1. Keep this tab OPEN (audio will help keep it active)
2. Click "ALLOW" if browser asks for audio permission
3. Install as PWA for best results
4. Keep device charged

Silent audio will play to prevent Chrome from suspending the app.

Do you want to continue?`;
                
                if (!confirm(warningMessage)) {
                    return;
                }
                
                try {
                    state.isBroadcasting = true;
                    app.updateBroadcastUI(true);
                    
                    // Start silent audio FIRST (this helps with background)
                    app.startSilentAudio();
                    
                    // Request wake lock
                    await app.requestWakeLock();
                    
                    // Start location tracking
                    app.startLocationTracking();
                    
                    // Start timers
                    app.startCountdown();
                    app.startUptimeTimer();
                    
                    // Show warnings
                    app.showFullscreenWarning();
                    
                    console.log("Broadcast started with silent audio");
                    
                } catch (error) {
                    console.error("Error starting broadcast:", error);
                    alert("Error starting trip: " + error.message);
                    app.stopBroadcast();
                }
            },

            startLocationTracking: () => {
                if (state.watchId) {
                    navigator.geolocation.clearWatch(state.watchId);
                    state.watchId = null;
                }
                
                state.currentSmoothedSpeed = 0;
                let isFirstFix = true;
                let lastPosition = null;
                
                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                };
                
                state.watchId = navigator.geolocation.watchPosition(
                    async (position) => {
                        if (!state.isBroadcasting) return;
                        
                        const { latitude, longitude, accuracy, speed, altitude, heading } = position.coords;
                        const now = Date.now();
                        
                        // Validate position
                        if (lastPosition) {
                            const distance = app.calculateDistance(
                                lastPosition.latitude, lastPosition.longitude,
                                latitude, longitude
                            );
                            const timeDiff = (now - lastPosition.timestamp) / 1000;
                            
                            if (timeDiff > 0 && distance / timeDiff > 200) {
                                console.warn("Unrealistic position jump, skipping");
                                return;
                            }
                        }
                        
                        lastPosition = { latitude, longitude, timestamp: now };
                        
                        // Same direction blocking
                        if (isFirstFix) {
                            let conflict = false;
                            const buses = Object.values(state.activeBuses);
                            
                            for (let bus of buses) {
                                if (bus.id === state.driverId) continue;
                                if (now - bus.ts > 60000) continue;
                                
                                if (bus.route === state.driverRoute) {
                                    const dist = app.calculateDistance(latitude, longitude, bus.lat, bus.lng);
                                    if (dist < 20) {
                                        conflict = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (conflict) {
                                alert("âš ï¸ Another driver is active nearby!");
                                app.stopBroadcast();
                                return;
                            }
                            isFirstFix = false;
                        }
                        
                        // Calculate speed
                        let rawSpeedKmh = (speed || 0) * 3.6;
                        let alpha = 0.15;
                        
                        if (state.currentSmoothedSpeed > rawSpeedKmh) {
                            alpha = 0.6;
                        }
                        
                        state.currentSmoothedSpeed = (state.currentSmoothedSpeed * (1 - alpha)) + (rawSpeedKmh * alpha);
                        
                        if (rawSpeedKmh < 0.2 && state.currentSmoothedSpeed < 2.0) {
                            state.currentSmoothedSpeed = 0;
                        }
                        
                        const displaySpeed = state.currentSmoothedSpeed.toFixed(1);
                        
                        // Update UI
                        document.getElementById('val-speed').innerHTML = `${displaySpeed}<span class="text-[10px] ml-0.5 text-slate-400 font-sans">km/h</span>`;
                        document.getElementById('val-accuracy').innerText = Math.round(accuracy) + 'm';
                        
                        // Update map
                        if (state.driverMarker) {
                            state.driverMarker.setLatLng([latitude, longitude]);
                            if (state.driverMap) {
                                state.driverMap.panTo([latitude, longitude], {
                                    animate: true,
                                    duration: 1
                                });
                            }
                        }
                        
                        state.lastLat = latitude;
                        state.lastLng = longitude;
                        
                        // Throttle MQTT messages
                        if (now - state.lastSentTime < CONFIG.locationInterval) return;
                        state.lastSentTime = now;
                        
                        // Send to MQTT
                        if (state.client && state.isConnected) {
                            const payload = JSON.stringify({
                                id: state.driverId,
                                uid: CONFIG.mqtt.clientId,
                                route: state.driverRoute,
                                username: state.driverUsername,
                                lat: latitude,
                                lng: longitude,
                                acc: accuracy,
                                speed: displaySpeed,
                                alt: altitude || null,
                                heading: heading || null,
                                ts: now,
                                visible: state.isTabVisible,
                                audio: state.isAudioPlaying,
                                battery: state.batteryLevel * 100
                            });
                            state.client.publish(CONFIG.topics.location, payload, { retain: true });
                        }
                    },
                    (error) => {
                        console.error("GPS Error:", error);
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                alert("Location permission denied!");
                                app.stopBroadcast();
                                break;
                            case error.POSITION_UNAVAILABLE:
                                console.log("Position unavailable");
                                break;
                            case error.TIMEOUT:
                                console.log("GPS timeout");
                                break;
                        }
                    },
                    options
                );
                
                // Fallback: Periodic position updates
                state.locationInterval = setInterval(() => {
                    if (!state.isBroadcasting || !state.isTabVisible) return;
                    
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            // Process position (similar to above)
                            const { latitude, longitude, accuracy } = position.coords;
                            const now = Date.now();
                            
                            if (state.client && state.isConnected && now - state.lastSentTime > 10000) {
                                const payload = JSON.stringify({
                                    id: state.driverId,
                                    lat: latitude,
                                    lng: longitude,
                                    acc: accuracy,
                                    ts: now,
                                    fallback: true
                                });
                                state.client.publish(CONFIG.topics.location, payload, { retain: true });
                            }
                        },
                        null,
                        { enableHighAccuracy: false, timeout: 5000, maximumAge: 30000 }
                    );
                }, 30000); // Every 30 seconds as fallback
            },

            startUptimeTimer: () => {
                if (state.uptimeInterval) clearInterval(state.uptimeInterval);
                
                state.uptimeInterval = setInterval(() => {
                    if (!state.isBroadcasting) return;
                    
                    const diff = Math.floor((Date.now() - state.tripStartTime) / 1000);
                    const m = Math.floor(diff / 60).toString().padStart(2, '0');
                    const s = (diff % 60).toString().padStart(2, '0');
                    const el = document.getElementById('val-uptime');
                    if(el) el.innerText = `${m}:${s}`;
                }, 1000);
            },

            // === MODIFIED STOP BROADCAST ===
            stopBroadcast: async () => {
                state.isBroadcasting = false;
                app.updateBroadcastUI(false);
                
                // Stop silent audio
                app.stopSilentAudio();
                
                // Release wake lock
                app.releaseWakeLock();
                
                // Stop countdown
                app.stopCountdown();
                
                // Clear all intervals
                if (state.watchId) {
                    navigator.geolocation.clearWatch(state.watchId);
                    state.watchId = null;
                }
                
                if (state.locationInterval) {
                    clearInterval(state.locationInterval);
                    state.locationInterval = null;
                }
                
                if (state.uptimeInterval) {
                    clearInterval(state.uptimeInterval);
                    state.uptimeInterval = null;
                }
                
                // Send offline status
                if (state.client && state.isConnected && state.driverId) {
                    state.client.publish(CONFIG.topics.location, JSON.stringify({
                        id: state.driverId,
                        status: 'offline',
                        ts: Date.now()
                    }), { retain: true });
                }
                
                // Clear from active buses
                if (state.driverId && state.activeBuses[state.driverId]) {
                    delete state.activeBuses[state.driverId];
                }
                
                // Reset UI
                document.getElementById('val-uptime').innerText = "00:00";
                document.getElementById('fullscreen-warning').classList.add('hidden');
                document.getElementById('battery-warning').classList.add('hidden');
                
                state.fullscreenWarningShown = false;
                
                app.showSummary();
            },

            // ... [Keep all your existing functions like goHome, updateBroadcastUI, etc.] ...
            // ... [Your existing MQTT, map, and other functions remain the same] ...

            // Add this function for testing audio
            testAudioPermission: () => {
                if (!CONFIG.silentAudio.enabled) return;
                
                const testAudio = new Audio();
                testAudio.volume = 0.001;
                testAudio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ';
                
                testAudio.play().then(() => {
                    console.log("Audio permission granted");
                    testAudio.pause();
                }).catch(error => {
                    console.log("Audio permission may be blocked:", error);
                    alert("Please allow audio permissions for background tracking to work.");
                });
            }
        };

        // Add event listeners for audio
        document.addEventListener('click', () => {
            // Try to resume audio context on any click
            if (state.audioContext && state.audioContext.state === 'suspended') {
                state.audioContext.resume();
            }
        });

        // Listen for audio autoplay issues
        document.addEventListener('play', (e) => {
            if (e.target.tagName === 'AUDIO' && state.isBroadcasting) {
                console.log("Audio started playing");
            }
        }, true);

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            state.isTabVisible = !document.hidden;
            
            if (state.isBroadcasting) {
                if (state.isTabVisible) {
                    console.log("Tab became visible");
                    // Try to resume audio if it was paused
                    if (state.silentAudio && !state.isAudioPlaying) {
                        setTimeout(() => app.startSilentAudio(), 1000);
                    }
                } else {
                    console.log("Tab hidden - silent audio should keep it active");
                    // Show notification if audio isn't playing
                    if (!state.isAudioPlaying && CONFIG.silentAudio.enabled) {
                        console.warn("Silent audio not playing - background may be limited");
                    }
                }
            }
        });

        // Listen for beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            state.deferredInstallPrompt = e;
            console.log("PWA install prompt available");
        });

        // Listen for appinstalled event
        window.addEventListener('appinstalled', () => {
            state.isInstalled = true;
            console.log('PWA was installed');
            document.getElementById('install-prompt').classList.add('hidden');
        });

        window.app = app;
        window.state = state;
        window.addEventListener('DOMContentLoaded', app.init);
    </script>
</body>
</html>
